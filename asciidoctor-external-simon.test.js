const asciidoctor = require('@asciidoctor/core')()
const registry = asciidoctor.Extensions.create()
require('./asciidoctor-external-callout.js')(registry)


require('./asciidoctor-external-callout')

test('Load Simon Dew test file', () => {

    let input_document = ` 
:source-highlighter: highlight.js
:icons: font
[source, c]
----
typedef struct CBLExternalKeyCallbacks
{
  /** Provides the public key's raw data as an ASN.1 DER sequence of [modulus, exponent]. */
  bool (*publicKeyData)(void* externalKey,
                        void* output,
                        size_t outputMaxLen,
                        size_t* outputLen);

  /** Decrypts data using the private key. */
  bool (*decrypt)(void* externalKey,
                  FLSlice input,
                  void* output,
                  size_t outputMaxLen,
                  size_t* outputLen);

  /** Uses the private key to generate a signature of input data. */
  bool (*sign)(void* externalKey,
               CBLSignatureDigestAlgorithm digestAlgorithm,
               FLSlice inputData,
               void* outSignature);

  /** ( Optional ) For freeing any resource when the callbacks are no longer needed.*/
  void (*_cbl_nullable free)(void* externalKey);
} CBLKeyPairCallbacks;
----
. The public key is part of an RSA key pair generated by a secure key storage or cryptographic API. @/publicKeyData/

. \`externalKey\` is an opaque pointer passed to {url-api-references-tlsidentity}#ga78d47a8c2157dad4347709d1adec6b39[CBLKeyPair_CreateWithExternalKey()], typically representing a reference or token used to access the public / private key within the secure storage system. @/externalKey/

. Use \`outputMaxLen\` as a guardrail to ensure the public key data size is within the expected range. @/outputMaxLen/

. Use RSA with PKCS#1 v1.5 padding.
Algorithm names may vary -- for example, RSA/ECB/PKCS1Padding on Java or Android.
Note that depending on the selected key exchange method, the \`decrypt()\` function may not be invoked during the TLS handshake. @/decrypt/

. You must use PKCS#1 v1.5 padding algorithm when generating the signature. @/CBLSignatureDigestAlgorithm/

. Ensure that the input data, which is already hashed based on the specified digest algorithm, is encoded as an ASN.1 DigestInfo structure in DER format before performing the signing operation.
Some cryptographic libraries may handle the DigestInfo formatting internally. @/inputData/
`
    let converted_doc = asciidoctor.convert(input_document,{safe: 'safe', standalone: true,
        extension_registry: registry})


    console.log(converted_doc)
})
